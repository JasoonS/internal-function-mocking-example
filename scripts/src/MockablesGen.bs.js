// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Curry = require("rescript/lib/js/curry.js");
var Globals = require("./library/Globals.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var SmockableGen = require("./library/SmockableGen.bs.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Belt_HashMapString = require("rescript/lib/js/belt_HashMapString.js");
var MockablesGenTemplates = require("./templates/MockablesGenTemplates.bs.js");

var filesToMockInternally = [
  "LongShort.sol",
  "Staker.sol"
];

var ScriptDoesNotSupportReturnValues = /* @__PURE__ */Caml_exceptions.create("MockablesGen.ScriptDoesNotSupportReturnValues");

var defaultError = "This script currently only supports functions that return or receive as parameters uints, ints, bools, (nonpayable) addresses, contracts, structs, arrays or strings\n          // NO MAPPINGS";

var abisToMockExternally = [
  "ERC20Mock",
  "YieldManagerMock",
  "LongShort",
  "SyntheticToken",
  "YieldManagerAave",
  "FloatCapital_v0",
  "TokenFactory",
  "FloatToken",
  "Staker",
  "Treasury_v0",
  "OracleManagerChainlink",
  "OracleManagerMock",
  "LendingPoolAaveMock",
  "LendingPoolAddressesProviderMock",
  "AaveIncentivesControllerMock"
];

function convertASTTypeToSolTypeSimple(typeDescriptionStr) {
  if (typeDescriptionStr.startsWith("contract ")) {
    return typeDescriptionStr.replace(/contract\s+/g, "");
  } else {
    return typeDescriptionStr;
  }
}

function convertASTTypeToSolType(typeDescriptionStr) {
  switch (typeDescriptionStr) {
    case "address" :
    case "bool" :
        return typeDescriptionStr;
    case "string" :
        return "string calldata ";
    default:
      if (Globals.containsRe(typeDescriptionStr, /\[/g)) {
        return typeDescriptionStr + " memory";
      }
      if (typeDescriptionStr.startsWith("uint")) {
        return typeDescriptionStr;
      }
      if (typeDescriptionStr.startsWith("int")) {
        return typeDescriptionStr;
      }
      if (typeDescriptionStr.startsWith("contract ")) {
        return typeDescriptionStr.replace(/contract\s+/g, "");
      }
      if (typeDescriptionStr.startsWith("enum ")) {
        return typeDescriptionStr.replace(/enum\s+/g, "");
      }
      if (typeDescriptionStr.startsWith("struct ")) {
        return typeDescriptionStr.replace(/struct\s+/g, "") + " memory ";
      }
      throw {
            RE_EXN_ID: ScriptDoesNotSupportReturnValues,
            _1: defaultError,
            Error: new Error()
          };
  }
}

function nodeToTypedIdentifier(node) {
  return {
          name: node.name,
          type_: node.typeDescriptions.typeString,
          storageLocation: node.storageLocation === "storage" ? /* Storage */0 : /* NotRelevant */1,
          storageLocationString: node.storageLocation
        };
}

function functionVirtualOrPure(nodeStatements) {
  return Belt_Array.map(Belt_Array.keep(Belt_Array.keep(nodeStatements, (function (x) {
                        if (x.nodeType === "FunctionDefinition") {
                          return x.name !== "";
                        } else {
                          return false;
                        }
                      })), (function (x) {
                    if (x.virtual) {
                      return true;
                    } else {
                      return x.pure;
                    }
                  })), (function (x) {
                var r_name = x.name;
                var r_parameters = Belt_Array.map(x.parameters.parameters, nodeToTypedIdentifier);
                var r_returnValues = Belt_Array.map(x.returnParameters.parameters, nodeToTypedIdentifier);
                var r_visibility = x.visibility === "public" || x.visibility === "external" ? /* Public */0 : /* Private */1;
                var r = {
                  name: r_name,
                  parameters: r_parameters,
                  returnValues: r_returnValues,
                  visibility: r_visibility
                };
                return [
                        r,
                        x
                      ];
              }));
}

function modifiers(nodeStatements) {
  return Belt_Array.map(Belt_Array.keep(nodeStatements, (function (x) {
                    return x.nodeType === "ModifierDefinition";
                  })), (function (x) {
                var r_name = x.name;
                var r_parameters = Belt_Array.map(x.parameters.parameters, nodeToTypedIdentifier);
                var r_returnValues = [];
                var r_visibility = x.visibility === "public" || x.visibility === "external" ? /* Public */0 : /* Private */1;
                var r = {
                  name: r_name,
                  parameters: r_parameters,
                  returnValues: r_returnValues,
                  visibility: r_visibility
                };
                return [
                        r,
                        x
                      ];
              }));
}

var lineCommentsRe = /\/\/[^\n]*\n/g;

var blockCommentsRe = /\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//g;

function getContractArtifact(fileNameWithoutExtension) {
  return require("../../contracts/abis/" + fileNameWithoutExtension + ".json");
}

function getContractAst(fileNameWithoutExtension) {
  return require("../../contracts/ast/" + fileNameWithoutExtension + ".json");
}

var BadMatchingBlock = /* @__PURE__ */Caml_exceptions.create("MockablesGen.BadMatchingBlock");

function matchingBlockEndIndex(str, _startIndex, _count) {
  while(true) {
    var count = _count;
    var startIndex = _startIndex;
    var charr = str.charAt(startIndex);
    if (charr === "}" && count === 1) {
      return startIndex;
    }
    if (charr === "}" && count > 1) {
      _count = count - 1 | 0;
      _startIndex = startIndex + 1 | 0;
      continue ;
    }
    if (charr === "{") {
      _count = count + 1 | 0;
      _startIndex = startIndex + 1 | 0;
      continue ;
    }
    if (charr !== "{" && charr !== "}") {
      _startIndex = startIndex + 1 | 0;
      continue ;
    }
    throw {
          RE_EXN_ID: BadMatchingBlock,
          Error: new Error()
        };
  };
}

var importRe = /import[^;]+;/g;

var quotesRe = /"[\S\s]*"/;

function resolveImportLocationRecursive(_array, __import) {
  while(true) {
    var _import = __import;
    var array = _array;
    if (!Globals.contains(_import, "/")) {
      return Belt_Array.reduce(array, "", (function (acc, curr) {
                    return acc + curr + "/";
                  })) + _import;
    }
    if (_import.startsWith("../")) {
      __import = _import.substring(3);
      _array = Belt_Array.reverse(Belt_Array.sliceToEnd(Belt_Array.reverse(array), 1));
      continue ;
    }
    if (_import.startsWith("./")) {
      __import = _import.substring(2);
      continue ;
    }
    var firstSlashIndex = _import.indexOf("/");
    __import = _import.substring(firstSlashIndex + 1 | 0);
    _array = Belt_Array.concat(array, [_import.substring(0, firstSlashIndex)]);
    continue ;
  };
}

function reduceStrArr(arr) {
  return Belt_Array.reduce(arr, "", (function (acc, curr) {
                return acc + curr;
              }));
}

function parseAbiTypes(types) {
  return Belt_Array.map(types, (function (i) {
                return {
                        name: i.name,
                        type_: i.internalType,
                        storageLocation: /* NotRelevant */1,
                        storageLocationString: "callable"
                      };
              }));
}

function parseAbi(abi) {
  return Belt_Array.map(Belt_Array.keep(abi, (function (n) {
                    return n.type === "function";
                  })), (function (n) {
                return {
                        name: n.name,
                        parameters: parseAbiTypes(n.inputs),
                        returnValues: parseAbiTypes(n.outputs),
                        visibility: /* Public */0
                      };
              }));
}

var bindingsDict = Belt_HashMapString.make(10);

Belt_Array.forEach(abisToMockExternally, (function (contractName) {
        var abi = getContractArtifact(contractName);
        var functions = parseAbi(abi);
        return Belt_HashMapString.set(bindingsDict, contractName, SmockableGen.externalModule(functions, contractName));
      }));

Belt_Array.forEach(filesToMockInternally, (function (filePath) {
        var filePathSplit = filePath.split("/");
        var fileName = Belt_Array.getExn(filePathSplit, filePathSplit.length - 1 | 0);
        var fileNameSplit = fileName.split(".");
        var fileNameWithoutExtension = reduceStrArr(Belt_Array.slice(fileNameSplit, 0, fileNameSplit.length > 1 ? fileNameSplit.length - 1 | 0 : fileNameSplit.length));
        var typeDefContainsFileName = new RegExp("\\s" + fileNameWithoutExtension + "\\.");
        var actionOnFileNameTypeDefs = function (action, type_) {
          if (Globals.containsRe(type_, typeDefContainsFileName)) {
            return Curry._1(action, type_);
          } else {
            return type_;
          }
        };
        var replaceFileNameTypeDefsWithMockableTypeDefs = function (param) {
          return actionOnFileNameTypeDefs((function (type_) {
                        return type_.replace(fileNameWithoutExtension + ".", fileNameWithoutExtension + "Mockable.");
                      }), param);
        };
        var removeFileNameFromTypeDefs = function (param) {
          return actionOnFileNameTypeDefs((function (type_) {
                        return type_.replace(typeDefContainsFileName, " ");
                      }), param);
        };
        var sol = {
          contents: Fs.readFileSync("../contracts/contracts/" + filePath, "utf8")
        };
        var lineCommentsMatch = Belt_Option.map(Caml_option.null_to_opt(sol.contents.match(lineCommentsRe)), (function (i) {
                return Belt_Array.keep(i, (function (x) {
                              return !Globals.contains(x, "SPDX-License-Identifier");
                            }));
              }));
        Belt_Option.map(lineCommentsMatch, (function (l) {
                return Belt_Array.forEach(l, (function (i) {
                              sol.contents = sol.contents.replace(i, "");
                              
                            }));
              }));
        sol.contents = sol.contents.replace(blockCommentsRe, "\n");
        var body = sol.contents;
        var contractAst = getContractAst(fileNameWithoutExtension);
        var contractDefinition = Belt_Array.getExn(Belt_Array.keep(contractAst.nodes, (function (x) {
                    return x.nodeType === "ContractDefinition";
                  })), 0);
        var mockLogger = {
          contents: ""
        };
        var allFunctions = Belt_Array.map(functionVirtualOrPure(contractDefinition.nodes), (function (param) {
                var original = param[1];
                var x = param[0];
                var isPure = original.stateMutability === "pure";
                var isExternal = original.visibility === "external";
                var indexOfOldFunctionDec = body.indexOf("function " + x.name + "(");
                var indexOfOldFunctionBodyStart = body.indexOf("{", indexOfOldFunctionDec);
                var originalFunctionDefinition = body.substring(indexOfOldFunctionDec, indexOfOldFunctionBodyStart + 1 | 0);
                var alreadyAnOverride = originalFunctionDefinition.indexOf("override") !== -1;
                var functionDefinition = originalFunctionDefinition.replace("virtual", alreadyAnOverride ? "" : "override");
                var storageParameters = Belt_Array.keep(x.parameters, (function (x) {
                        return x.storageLocation === /* Storage */0;
                      }));
                var mockerParameterCalls = Globals.commafiy(Belt_Array.map(x.parameters, (function (x) {
                            if (x.storageLocation === /* Storage */0) {
                              return x.name + "_temp1";
                            } else {
                              return x.name;
                            }
                          })));
                var mockerArguments = Globals.commafiy(Belt_Array.map(x.parameters, (function (x) {
                            return convertASTTypeToSolType(replaceFileNameTypeDefsWithMockableTypeDefs(x.type_));
                          })));
                var storageParametersFormatted = reduceStrArr(Belt_Array.map(storageParameters, (function (x) {
                            return "\n          " + convertASTTypeToSolType(removeFileNameFromTypeDefs(x.type_)) + " " + x.name + "_temp1 = " + x.name + ";\n        ";
                          })));
                var arr = x.returnValues;
                var mockerReturnValues = arr.length !== 0 ? "returns (" + Globals.commafiy(Belt_Array.map(arr, (function (x) {
                              return convertASTTypeToSolType(x.type_) + " " + x.name;
                            }))) + ")" : "";
                var exposedCallArguments = Globals.commafiy(Belt_Array.map(x.parameters, (function (x) {
                            var storageLocation = x.storageLocationString === "default" ? "" : x.storageLocationString;
                            return convertASTTypeToSolTypeSimple(x.type_) + " " + storageLocation + " " + x.name;
                          })));
                var stateMutabilityText = original.stateMutability === "nonpayable" ? "" : original.stateMutability;
                var match = x.visibility;
                var exposedFunction = match ? "function " + x.name + "Exposed(" + exposedCallArguments + ") external " + stateMutabilityText + " " + mockerReturnValues + " { return super." + x.name + "(" + mockerParameterCalls + ");}\n" : "";
                var result = isExternal ? "" : exposedFunction + (
                    isPure ? "\n" : functionDefinition + MockablesGenTemplates.mockableFunctionBody(x.name, storageParametersFormatted, mockerParameterCalls)
                  );
                var mockerReturn = Globals.commafiy(Belt_Array.map(x.returnValues, (function (y) {
                            return "abi.decode(\"\",(" + convertASTTypeToSolType(y.type_) + "))";
                          })));
                mockLogger.contents = mockLogger.contents + MockablesGenTemplates.externalMockerFunctionBody(x.name, mockerArguments, mockerReturnValues, mockerReturn);
                return result;
              }));
        var importsInFile = body.match(importRe);
        var importsInFile$1 = importsInFile === null ? undefined : Caml_option.some(importsInFile);
        var importsInFileReplaced = Belt_Option.map(importsInFile$1, (function (i) {
                return Belt_Array.map(i, (function (x) {
                              if (!Globals.contains(x, "..") && !Globals.contains(x, "./")) {
                                return x;
                              }
                              var impStatement = Belt_Array.getExn(Belt_Option.getExn(Caml_option.null_to_opt(x.match(quotesRe))), 0);
                              var impStatement$1 = impStatement.substring(1, impStatement.length);
                              var initialDirStructure = filePath.split("/");
                              var initialDirStructure$1 = Belt_Array.slice(initialDirStructure, 0, initialDirStructure.length - 1 | 0);
                              return x.replace(impStatement$1, "../../" + resolveImportLocationRecursive(initialDirStructure$1, impStatement$1));
                            }));
              }));
        Belt_Option.map(importsInFile$1, (function (i) {
                return Belt_Array.forEachWithIndex(i, (function (index, imp) {
                              sol.contents = sol.contents.replace(imp, importsInFileReplaced[index]);
                              
                            }));
              }));
        var parentImports = Belt_Option.mapWithDefault(importsInFileReplaced, "", (function (i) {
                return reduceStrArr(Belt_Array.map(i, (function (z) {
                                  return z + "\n";
                                })));
              }));
        mockLogger.contents = MockablesGenTemplates.internalMockingFileTemplate(fileNameWithoutExtension, parentImports, mockLogger.contents);
        var indexOfFirstImports = body.indexOf("import");
        var prefix = body.substring(0, indexOfFirstImports) + parentImports;
        var allFunctionsString = allFunctions.join("\n");
        var contractMockable = MockablesGenTemplates.mockingFileTemplate(prefix, fileNameWithoutExtension, allFunctionsString);
        var outputDirectory = "../contracts/contracts/testing/generated";
        if (!Fs.existsSync(outputDirectory)) {
          Fs.mkdirSync(outputDirectory, {
                recursive: true
              });
        }
        Fs.writeFileSync(outputDirectory + "/" + fileNameWithoutExtension + "Mockable.sol", contractMockable, "utf8");
        Fs.writeFileSync(outputDirectory + "/" + fileNameWithoutExtension + "ForInternalMocking.sol", mockLogger.contents, "utf8");
        var existingModuleDef = Belt_Array.some(abisToMockExternally, (function (x) {
                return x === fileNameWithoutExtension;
              })) ? Belt_Option.getExn(Belt_HashMapString.get(bindingsDict, fileNameWithoutExtension)) : "";
        return Belt_HashMapString.set(bindingsDict, fileNameWithoutExtension, existingModuleDef + "\n\n" + SmockableGen.internalModule(Belt_Array.map(functionVirtualOrPure(contractDefinition.nodes), (function (param) {
                              return param[0];
                            })), fileNameWithoutExtension));
      }));

Belt_HashMapString.forEach(bindingsDict, (function (key, val) {
        Fs.writeFileSync("../contracts/test-waffle/library/smock/" + key + "Smocked.res", val, "utf8");
        
      }));

var contains = Globals.contains;

var containsRe = Globals.containsRe;

var commafiy = Globals.commafiy;

exports.filesToMockInternally = filesToMockInternally;
exports.ScriptDoesNotSupportReturnValues = ScriptDoesNotSupportReturnValues;
exports.defaultError = defaultError;
exports.contains = contains;
exports.containsRe = containsRe;
exports.commafiy = commafiy;
exports.abisToMockExternally = abisToMockExternally;
exports.convertASTTypeToSolTypeSimple = convertASTTypeToSolTypeSimple;
exports.convertASTTypeToSolType = convertASTTypeToSolType;
exports.nodeToTypedIdentifier = nodeToTypedIdentifier;
exports.functionVirtualOrPure = functionVirtualOrPure;
exports.modifiers = modifiers;
exports.lineCommentsRe = lineCommentsRe;
exports.blockCommentsRe = blockCommentsRe;
exports.getContractArtifact = getContractArtifact;
exports.getContractAst = getContractAst;
exports.BadMatchingBlock = BadMatchingBlock;
exports.matchingBlockEndIndex = matchingBlockEndIndex;
exports.importRe = importRe;
exports.quotesRe = quotesRe;
exports.resolveImportLocationRecursive = resolveImportLocationRecursive;
exports.reduceStrArr = reduceStrArr;
exports.parseAbiTypes = parseAbiTypes;
exports.parseAbi = parseAbi;
exports.bindingsDict = bindingsDict;
/* bindingsDict Not a pure module */
