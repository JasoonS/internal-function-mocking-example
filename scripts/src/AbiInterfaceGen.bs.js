// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");

var files = Fs.readdirSync("../contracts/abis");

function startsWith(prim0, prim1) {
  return prim0.startsWith(prim1);
}

var lowerCaseFirstLetter = ((someString) => someString.charAt(0).toLowerCase() + someString.slice(1));

var removePrefixUnderscores = ((someString) => {
  if (someString.charAt(0) == "_") {
    return someString.slice(1)
  } else {
    return someString
  }
});

function formatKeywords(keyword) {
  if (keyword === "to") {
    return "_" + keyword;
  } else {
    return removePrefixUnderscores(keyword);
  }
}

function getMmoduleName(fileName) {
  return fileName.split(".")[0];
}

function getRescriptType(typeString) {
  if (typeString === "bool") {
    return "bool";
  } else if (typeString === "bytes" || typeString === "bytes32") {
    return "bytes32";
  } else if (typeString === "uint16" || typeString === "uint32") {
    return "int";
  } else if (typeString === "address[]") {
    return "array<Ethers.ethAddress>";
  } else if (typeString === "string") {
    return "string";
  } else if (typeString === "uint32[]") {
    return "array<int>";
  } else if (typeString === "address") {
    return "Ethers.ethAddress";
  } else if (typeString === "int256" || typeString === "uint256") {
    return "Ethers.BigNumber.t";
  } else if (typeString === "uint8") {
    return "int";
  } else if (typeString === "bytes4") {
    return "bytes4";
  } else if (typeString.startsWith("tuple")) {
    return "tuple";
  } else {
    console.log("Please handle all types - " + typeString + " isn't handled by this script.");
    return "unknownType";
  }
}

function typeInputs(inputs, paramLayout) {
  var paramsString = {
    contents: ""
  };
  Belt_Array.mapWithIndex(inputs, (function (index, input) {
          var paramType = input.type;
          var parameterIsNamed = input.name !== "";
          var paramName = input.name === "" ? "param" + String(index) : formatKeywords(input.name);
          var rescriptType = getRescriptType(paramType);
          var tmp;
          switch (paramLayout) {
            case /* NamedTyped */0 :
                tmp = (
                  parameterIsNamed ? "~" + paramName + ":" : ""
                ) + " " + rescriptType + ",";
                break;
            case /* NamedUntyped */1 :
                tmp = (
                  parameterIsNamed ? "~" : ""
                ) + paramName + ",";
                break;
            case /* UnnamedUntyped */2 :
                tmp = paramName + ",";
                break;
            
          }
          paramsString.contents = paramsString.contents + tmp;
          
        }));
  return paramsString.contents;
}

function typeOutputs(outputs, functionName) {
  var paramsString = {
    contents: ""
  };
  if (outputs.length > 1) {
    Belt_Array.mapWithIndex(outputs, (function (index, output) {
            var paramType = output.type;
            var paramName = output.name === "" ? "param" + String(index) : formatKeywords(output.name);
            var rescriptType = getRescriptType(paramType);
            paramsString.contents = paramsString.contents + ("\n" + paramName + ": " + rescriptType + ",");
            
          }));
    return "type " + functionName + "Return = {" + paramsString.contents + "\n    }";
  }
  if (outputs.length !== 1) {
    return "type " + lowerCaseFirstLetter(functionName) + "Return";
  }
  var rescriptType = getRescriptType(outputs[0].type);
  return "type " + lowerCaseFirstLetter(functionName) + "Return = " + rescriptType;
}

function generateConstructor(constructorParams, moduleName) {
  var typeNamesFull = typeInputs(constructorParams, /* NamedTyped */0);
  var typeNames = typeInputs(constructorParams, /* NamedUntyped */1);
  var callParams = typeInputs(constructorParams, /* UnnamedUntyped */2);
  return "let make: (" + typeNamesFull + ") => JsPromise.t<t> = (" + typeNames + ") =>\n    deployContract" + String(constructorParams.length) + "(contractName, " + callParams + ")->Obj.magic\n\n    let makeSmock: (" + typeNamesFull + ") => JsPromise.t<t> = (" + typeNames + ") =>\n    deployMockContract" + String(constructorParams.length) + "(contractName, " + callParams + ")->Obj.magic\n\n    let setVariable: (t, ~name: string, ~value: 'a) => JsPromise.t<unit> = setVariableRaw\n    \n    ";
}

var moduleDictionary = {};

Belt_Array.map(files, (function (abiFileName) {
        var abiFileContents = Fs.readFileSync("../contracts/abis/" + abiFileName, "utf8");
        var abiFileObject = JSON.parse(abiFileContents);
        var moduleName = getMmoduleName(abiFileName);
        var moduleContents = {};
        var moduleConstructor = {
          contents: "let make: unit => JsPromise.t<t> = () => deployContract0(contractName)->Obj.magic\n    let makeSmock: unit => JsPromise.t<t> = () => deployMockContract0(contractName)->Obj.magic\n\n    let setVariable: (t, ~name: string, ~value: 'a) => JsPromise.t<unit> = setVariableRaw\n    "
        };
        Belt_Array.map(abiFileObject, (function (abiItem) {
                var name = abiItem.name;
                var itemType = abiItem.type;
                var inputs = abiItem.inputs;
                if (itemType === "event") {
                  console.log("we have an event - " + name);
                  return ;
                }
                if (itemType !== "function") {
                  if (itemType === "constructor") {
                    moduleConstructor.contents = generateConstructor(inputs, moduleName);
                  } else {
                    console.log("We have an unhandled type - " + name + " " + itemType, abiItem);
                  }
                  return ;
                }
                var outputs = abiItem.outputs;
                var hasReturnValues = outputs.length !== 0;
                var stateMutability = abiItem.stateMutability;
                var typeNames = typeInputs(inputs, /* NamedTyped */0);
                var returnType = lowerCaseFirstLetter(name + "Return");
                var returnTypeDefinition = typeOutputs(outputs, name);
                if (stateMutability === "view" || stateMutability === "pure") {
                  moduleContents[name] = "\n  " + returnTypeDefinition + "\n  @send\n  external " + lowerCaseFirstLetter(name) + ": (\n    t," + typeNames + "\n  ) => JsPromise.t<" + returnType + "> = \"" + name + "\"\n";
                  return ;
                }
                var callVersion = hasReturnValues ? "\n    " + returnTypeDefinition + "\n    @send @scope(\"callStatic\")\n    external " + name + "Call: (\n      t," + typeNames + "\n    ) => JsPromise.t<" + returnType + "> = \"" + name + "\"\n" : "";
                moduleContents[name] = "\n  @send\n  external " + name + ": (\n    t," + typeNames + "\n  ) => JsPromise.t<transaction> = \"" + name + "\"\n" + callVersion;
                
              }));
        moduleDictionary[moduleName] = [
          moduleContents,
          moduleConstructor.contents
        ];
        
      }));

var _writeFiles = Belt_Array.map(Js_dict.entries(moduleDictionary), (function (param) {
        var moduleName = param[0];
        if (moduleName.endsWith("Mockable")) {
          return ;
        }
        var match = param[1];
        var optExposedFunctions = Js_dict.get(moduleDictionary, moduleName + "Mockable");
        var exposedFunctionBinding = optExposedFunctions !== undefined ? "module Exposed = {\n          let contractName = \"" + moduleName + "Mockable\"\n\n          " + optExposedFunctions[1] + "\n          " + Caml_splice_call.spliceObjApply("", "concat", [Js_dict.values(optExposedFunctions[0])]) + "\n        }" : "";
        Fs.writeFileSync("../contracts/test-waffle/library/contracts/" + moduleName + ".res", "\n@@ocaml.warning(\"-32\")\nopen SmockGeneral\nopen ContractHelpers\ntype t = {address: Ethers.ethAddress}\nlet contractName = \"" + moduleName + "\"\n\nlet at: Ethers.ethAddress => JsPromise.t<t> = contractAddress =>\n  attachToContract(contractName, ~contractAddress)->Obj.magic\n\n" + match[1] + "\n\n" + Caml_splice_call.spliceObjApply("", "concat", [Js_dict.values(match[0])]) + "\n\n" + exposedFunctionBinding + "\n", "utf8");
        
      }));

exports.files = files;
exports.startsWith = startsWith;
exports.lowerCaseFirstLetter = lowerCaseFirstLetter;
exports.removePrefixUnderscores = removePrefixUnderscores;
exports.formatKeywords = formatKeywords;
exports.getMmoduleName = getMmoduleName;
exports.getRescriptType = getRescriptType;
exports.typeInputs = typeInputs;
exports.typeOutputs = typeOutputs;
exports.generateConstructor = generateConstructor;
exports.moduleDictionary = moduleDictionary;
exports._writeFiles = _writeFiles;
/* files Not a pure module */
